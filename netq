#!/bin/sh
#
# Author: Pooya Moradi
# Date : 2021-05-07
# License: MIT
#
# Description: A handy network query tool in POSIX shell
#              Features local/public IP finding, bandwidth
#              monitoring, internet connection checking
# Dependencies: ip | ifconfig | hostname | nmcli
#               curl | wget
#               dig | host | nslookup
#               jq, ping, awk, bc, date, grep, tr, uname

version=0.36
l_sep="@" # separator between local IP and device/SSID name
p_sep="•" # separator between public IP and country
# default query priority, move up the desired line to prioritize
finders=$(
    cat << EOF
cloudflare.com
ipinfo.io
ip.network
ifconfig.io
ifconfig.co
ip-api.com
bare-checkip.amazonaws.com
bare-ipify.org
bare-ifconfig.me
bare-icanhazip.com
dns-google
dns-cloudflare
dns-toys
dns-akamai
EOF
)
IPSTACK_KEY=""                     # if set, add "ipstack.com" to finders above
check_url="https://www.google.com" # default test url for check
ping_ip="8.8.8.8"                  # default ping ip for check
special_formatting=0               # use symbols in STDOUT when output is empty
log_debug_flag=""
log_quiet_flag=""
ipv6_flag=0
public_raw=""
downloader=""

show_help() {
    cat << EOF
Usage: netq [OPTIONS] COMMAND [OPTIONS] ARGS
    netq local                  : Print local IP and network name (SSID, etc)
    netq public                 : Print public IP and country code (if possible)
    netq public -l              : List public IP finder methods
    netq public "FINDERS_CSV"   : Print public IP using passed finders
    netq public -e EXCL_REGEX   : Print public IP using filtered (BRE) finders
    netq public -r              : Print raw response from public IP finder
    netq bandwidth INTERFACE    : Watch bandwidth usage of INTERFACE
    netq check                  : Check internet connectivity
    netq check URL              : Check whether URL can be downloaded
    netq check -p               : Check internet connectivity via ping (on loop)
    netq list                   : List interfaces
    netq help                   : Show help
Options:
    -4: IPv4 mode (default)
    -6: IPv6 mode
    -q: Suppress all logs even errors
    -v: Enable debug logs
    -V: Print version
    -h: Show help
Command aliases:
    local: l, public: p, bandwidth: b|bw, check: c, list: ls
EOF
}

log() {
    [ -n "$log_quiet_flag" ] && return
    _mode=""
    case "$1" in
        "error")
            _mode="error"
            ;;
        "warn")
            _mode="warn"
            ;;
        "info")
            _mode="info"
            ;;
        "debug")
            _mode="debug"
            ;;
    esac
    # skip debug logs if flag is not set
    if [ $_mode = "debug" ] && [ -z "$log_debug_flag" ]; then
        return
    fi
    printf >&2 "[%-5s] %s\n" "$_mode" "$2"
}

check_deps() {
    OPTIND=1
    _silent=""
    while getopts q opt; do
        case $opt in
            q)
                _silent=1
                ;;
            *)
                log error "Bad usage!"
                return 2
                ;;
        esac
    done
    shift "$((OPTIND - 1))"
    _err=0
    for _app in "$@"; do
        if ! command -v "$_app" > /dev/null 2>&1; then
            [ -z "$_silent" ] && log error "dependency $_app not found"
            _err=1
        fi
    done
    return "$_err"
}

check_deps_any() {
    _err=1
    for _app in "$@"; do
        if command -v "$_app" > /dev/null 2>&1; then
            printf "%s" "$_app"
            return
        fi
    done
    log error "None of the dependencies '$*' were found (one is required)"
    return "$_err"
}

fetch() {
    if [ "$ipv6_flag" -eq 1 ]; then
        _network="6"
    else
        _network="4"
    fi

    if ! downloader=$(check_deps_any curl wget); then
        return 1
    fi
    _timeout=10 # seconds
    case $downloader in
        curl)
            if ! curl --silent --show-error --fail -"$_network" \
                --max-time "$_timeout" "$1"; then
                return 1
            fi
            ;;
        wget)
            # check if this is busybox
            if wget -V 2>&1 | grep -q -i 'busybox'; then
                if ! wget -q -T "$_timeout" -O- "$1"; then
                    return 1
                fi
                return
            fi

            if ! wget --quiet -"$_network" --timeout="$_timeout" \
                -O- "$1"; then
                return 1
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

show_local_ip() {
    # NetworkManager
    if check_deps -q nmcli; then
        if [ "$ipv6_flag" -eq 1 ]; then
            result=$(nmcli -t -f GENERAL.CONNECTION,IP6.ADDRESS device show \
                | awk -v sep="$l_sep" \
                    '/GENERAL.CONNECTION:/{
                      gsub(/GENERAL.CONNECTION:/, "");
                      con_id=$0}
                      /IP6.ADDRESS\[1\]:/{
                      gsub(/IP6.ADDRESS\[1\]:/, "");
                      ip=$0;
                      if (con_id && ip) {
                        split(ip, ip_arr, "/");
                        ipv6=ip_arr[1];
                        print ipv6 sep con_id
                      }}')
        else
            result=$(nmcli -t -f GENERAL.CONNECTION,IP4.ADDRESS device show \
                | awk -F: -v sep="$l_sep" \
                    '/GENERAL.CONNECTION:/{con_id=$2}
                   /IP4.ADDRESS\[1\]:/{ip=$2}
                   (con_id && ip) {
                       split(ip, ip_arr, "/");
                       print ip_arr[1] sep con_id;
                       ip="";con_id="";
                   }')
        fi
    # ip
    elif check_deps -q ip; then
        # handle busybox
        if ip -V 2>&1 | grep -i -q 'busybox'; then
            if [ "$ipv6_flag" -eq 1 ]; then
                ip -o -6 addr \
                    | awk -v sep="$l_sep" \
                        '/inet6/ { split($4, ip, "/"); print ip[1] sep $2 }'
            else
                ip -o -4 addr \
                    | awk -v sep="$l_sep" \
                        '/inet/ { split($4, ip, "/"); print ip[1] sep $2 }'
            fi
            return
        fi

        if [ "$ipv6_flag" -eq 1 ]; then
            result=$(ip -6 -brief address \
                | awk -F'[[:space:]/]+' -v sep="$l_sep" '
                     ($2 == "UP") {print $3 sep $1} ')
            if [ -z "$result" ]; then
                result=$(ip -6 -brief address \
                    | awk -F'[[:space:]/]+' -v sep="$l_sep" '
                     {print $3 sep $1} ')
            fi
        else
            result=$(ip -4 -brief address \
                | awk -F'[[:space:]/]+' -v sep="$l_sep" '
                     ($2 == "UP") {print $3 sep $1} ')
            if [ -z "$result" ]; then
                result=$(ip -4 -brief address \
                    | awk -F'[[:space:]/]+' -v sep="$l_sep" '
                     {print $3 sep $1} ')
            fi
        fi
    # ifconfig
    elif check_deps -q ifconfig; then
        if [ "$ipv6_flag" -eq 1 ]; then
            result=$(ifconfig | awk -v sep="$l_sep" '
                      /^[a-zA-Z]/ {interface=$1; sub(/:$/, "", interface)}
                      /inet6/ {print $2 sep interface}')
        else
            result=$(ifconfig | awk -v sep="$l_sep" '
                      /^[a-zA-Z]/ {interface=$1; sub(/:$/, "", interface)}
                      /inet [0-9]/ {print $2 sep interface}')
        fi
    # hostname -I
    elif result=$(hostname -I 2> /dev/null); then
        result="$(printf "%s" "$result" | tr ' ' '\n')"

    # handle windows/msys2 case
    elif uname -a | grep -q -i 'mingw'; then
        check_deps netsh
        result=$(netsh interface ip show addresses \
            | awk -v sep="$l_sep" 'BEGIN {RS = ""} {
               if (match($0, /"([^"]*)"/)) {
                 interface = substr($0, RSTART+1, RLENGTH-2);
                 match($0, /IP Address:[ \t]+([0-9.]+)/, addr);
                 if (length(addr) > 1) print addr[1] sep interface
                 }
               }')
    else
        log error "Unsupported platform"
    fi

    if [ -n "$result" ]; then
        printf "%s\n" "$result"
    else
        if [ "$special_formatting" -eq 1 ]; then
            printf "%s\n" "$l_sep"
        else
            log error "No local IP was found"
        fi
        exit 1
    fi
}

get_cloudflare() {
    _resp=""
    _ip=""
    _country=""
    _finder="cloudflare"

    # using cloudflare trace service
    if ! _resp=$(fetch "https://www.cloudflare.com/cdn-cgi/trace"); then
        log error "Failed to get public IP using $_finder "
        return 1
    fi

    if [ -n "$public_raw" ]; then
        printf "%s\n" "$_resp"
        return
    fi

    _ip=$(printf "%s" "$_resp" \
        | awk -F'\n' '/^ip=/{ip=substr($1, 4)} END{print ip}')
    _country=$(printf "%s" "$_resp" \
        | awk -F'\n' '/^loc=/{loc=substr($1, 5)} END{print loc}')

    if [ -n "$_ip" ]; then
        printf "%s • %s\n" "$_ip" "$_country"
    fi
}

get_ip_by_query_json() {
    _finder="$1"
    _endpoint="$2"
    _filter="$3"
    _resp=""

    if ! _resp=$(fetch "$_endpoint"); then
        log error "Failed to get public IP using $_finder "
        return 1
    fi

    if [ -n "$public_raw" ]; then
        printf "%s\n" "$_resp"
        return
    fi

    if ! check_deps jq; then
        log error "Failed to get public IP using $_finder "
        return 1
    fi

    if ! printf "%s" "$_resp" \
        | jq --raw-output --exit-status \
            "[$_filter \
                 | if . then . else error(\"No such key. Bad filter\") end] \
                 | join(\" $p_sep \")"; then
        return 1
    fi
}

get_ip_by_query_text() {
    _finder="$1"
    _endpoint="$2"
    _resp=""

    if ! _resp=$(fetch "$_endpoint"); then
        log error "Failed to get public IP using $_finder"
        return 1
    fi
    printf "%s\n" "$_resp"
}

get_ip_by_query_text_ip_api() {
    if [ -n "$public_raw" ]; then
        if ! _resp=$(get_ip_by_query_text \
            "ip-api.com" \
            "http://ip-api.com/json/?fields=66846719"); then
            return 1
        fi
        printf "%s\n" "$_resp"
        return
    else
        if ! _resp=$(get_ip_by_query_text \
            "ip-api.com" \
            "http://ip-api.com/csv/?fields=countryCode,query"); then
            return 1
        fi
        printf "%s\n" "$_resp" | awk -F"," -v sep=" $p_sep " '{print $2 sep $1}'
    fi
}

get_ip_by_dns() {
    _finder="$1"
    _name="$2"
    _server="$3"
    _type="$4"
    _class="$5"
    _res=""
    if [ "$ipv6_flag" -eq 1 ]; then
        _network="6"
    else
        _network="4"
    fi
    if check_deps -q dig; then
        if ! _res=$(dig -"$_network" \
            +short @"$_server" -c "$_class" -t "$_type" "$_name"); then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        if [ -z "$_res" ]; then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        if [ -n "$public_raw" ]; then
            printf "%s\n" "$_res"
            return
        fi

        _res2=$(printf "%s\n" "$_res" | awk -F '"' '{print $2}')

        if [ -z "$_res2" ]; then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        printf "%s\n" "$_res2"

    elif check_deps -q host; then
        if ! _res=$(host -"$_network" \
            -t "$_type" -c "$_class" "$_name" "$_server"); then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        if [ -z "$_res" ]; then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        if [ -n "$public_raw" ]; then
            printf "%s\n" "$_res"
            return
        fi

        printf "%s\n" "$_res" | awk -F '"' '/text/ {print $2}'

    elif check_deps -q nslookup; then
        # busybox nslookup doesn't have -class
        if [ "$_class" = "IN" ]; then
            if ! _res=$(nslookup -type="$_type" "$_name" "$_server"); then
                log error "Failed to get public IP using $_finder"
                return 1
            fi
        else
            if ! _res=$(nslookup -type="$_type" -class="$_class" \
                "$_name" "$_server"); then
                log error "Failed to get public IP using $_finder"
                return 1
            fi
        fi

        if [ -z "$_res" ]; then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        if [ -n "$public_raw" ]; then
            printf "%s\n" "$_res"
            return
        fi

        _res2=$(printf "%s\n" "$_res" | awk -F '"' '/text/ {print $2}')

        # see if we're dealing with windows nslookup here
        if command -v nslookup 2>&1 | grep -q -i 'windows/system32'; then
            # windows nslookup output formatting differs from bind9-dnsutils
            _res2=$(printf "%s\n" "$_res" | awk -F '"' 'NF > 1 {print $2}')
            if [ -z "$_res2" ]; then
                _res2=$(printf "%s\n" "$_res" \
                    | awk -F ' = ' '/address/ {print $2}')
            fi
            [ -z "$_res2" ] && return 1
        fi
        printf "%s\n" "$_res2"
    else
        check_deps_any dig nslookup host > /dev/null
        log error "Failed to get public IP using $_finder"
        return 1
    fi
}

get_ip_by_dns_akamai() {
    _finder="dns-akamai"
    _name="whoami.akamai.net"
    _server="ns1-1.akamaitech.net"
    _type="ANY"

    if [ "$ipv6_flag" -eq 1 ]; then
        # No IPv6 for ns1-1.akamaitech.net
        log error "Failed to get public IP using $_finder"
        return 1
    else
        _network=4
    fi

    if check_deps -q dig; then
        if ! _res=$(dig -"$_network" \
            +short @"$_server" -t "$_type" "$_name"); then
            log error "Failed to get public IP using $_finder"
            return 1
        fi
        if [ -z "$_res" ]; then
            log error "Failed to get public IP using $_finder"
            return 1
        fi
        printf "%s\n" "$_res"

    elif check_deps -q host; then
        if ! _res=$(host -"$_network" \
            -t "$_type" "$_name" "$_server"); then
            log error "Failed to get public IP using $_finder"
            return 1
        fi
        if [ -z "$_res" ]; then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        if [ -n "$public_raw" ]; then
            printf "%s\n" "$_res"
            return
        fi

        printf "%s\n" "$_res" | awk '/has address/ {print $4}'

    elif check_deps -q nslookup; then
        # busybox nslookup doesn't have -class
        if ! _res=$(nslookup -type="$_type" "$_name" "$_server"); then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        if [ -z "$_res" ]; then
            log error "Failed to get public IP using $_finder"
            return 1
        fi

        if [ -n "$public_raw" ]; then
            printf "%s\n" "$_res"
            return
        fi

        _res2=$(printf "%s\n" "$_res" \
            | awk '/Address:/ && /[0-9.]/ && !/#/ && $2 !~ /:/ { print $2 }')

        # see if we're dealing with windows nslookup here
        if command -v nslookup 2>&1 | grep -q -i 'windows/system32'; then
            # windows nslookup output formatting differs from bind9-dnsutils
            _res2=$(printf "%s\n" "$_res" | awk -F '"' 'NF > 1 {print $2}')
            if [ -z "$_res2" ]; then
                _res2=$(printf "%s\n" "$_res" \
                    | awk -F ' = ' '/address/ {print $2}')
            fi
            [ -z "$_res2" ] && return 1
        fi

        printf "%s\n" "$_res2"
    else
        check_deps_any dig nslookup host > /dev/null
        log error "Failed to get public IP using $_finder"
        return 1
    fi
}

get_ip_by_dns_cloudflare() {
    _finder="dns-cloudflare"
    if [ "$ipv6_flag" -eq 1 ]; then
        _server="2606:4700:4700::1001"
    else
        _server="1.0.0.1"
    fi

    _chaos="CH"
    # handle special case of windows nslookup
    if command -v nslookup 2>&1 | grep -q -i 'windows/system32'; then
        # unlike bind9-dnsutils, windows implementation knows "CHAOS"
        _chaos="CHAOS"
    fi

    if ! _res=$(get_ip_by_dns "dns-cloudflare" \
        "whoami.cloudflare" \
        "$_server" \
        "TXT" \
        "$_chaos"); then
        return 1
    fi
    if [ -n "$_res" ]; then
        printf "%s\n" "$_res"
    else
        return 1
    fi
}

get_public_ip() {
    case "$1" in
        "cloudflare.com")
            get_cloudflare
            ;;
        "ip.network")
            get_ip_by_query_json "$1" \
                "https://ip.network/more" \
                ".ip, .country"
            ;;
        "ipstack.com")
            get_ip_by_query_json "$1" \
                "https://api.ipstack.com/check?access_key=$IPSTACK_KEY" \
                ".ip, .country_code"
            ;;
        "ipinfo.io")
            get_ip_by_query_json "$1" \
                "https://ipinfo.io" \
                ".ip, .country"
            ;;
        "ifconfig.io")
            get_ip_by_query_json "$1" \
                "https://ifconfig.io/all.json" \
                ".ip, .country_code"
            ;;
        "ifconfig.co")
            get_ip_by_query_json "$1" \
                "https://ifconfig.co/json" \
                ".ip, .country_iso"
            ;;
        "ip-api.com")
            get_ip_by_query_text_ip_api
            ;;
        "bare-ipify.org")
            get_ip_by_query_text "$1" \
                "https://api64.ipify.org"
            ;;
        "bare-ifconfig.me")
            get_ip_by_query_text "$1" \
                "ifconfig.me/ip"
            ;;
        "bare-icanhazip.com")
            get_ip_by_query_text "$1" \
                "https://icanhazip.com"
            ;;
        "bare-checkip.amazonaws.com")
            get_ip_by_query_text "$1" \
                "https://checkip.amazonaws.com"
            ;;
        "dns-google")
            get_ip_by_dns "$1" \
                "o-o.myaddr.l.google.com" \
                "ns1.google.com" \
                "TXT" \
                "IN"
            ;;
        "dns-cloudflare")
            get_ip_by_dns_cloudflare
            ;;
        "dns-toys")
            get_ip_by_dns "$1" \
                "ip" \
                "dns.toys" \
                "TXT" \
                "IN"
            ;;
        "dns-akamai")
            get_ip_by_dns_akamai
            ;;
        *)
            log error "Unsupported finder method: $1"
            return 1
            ;;
    esac
}

# sanitization is needed since 'busybox wget' and 'nslookup' can't enforce
# connection through v4 or v6 networks
get_public_ip_santinized() {
    finder="$1"
    if ! result=$(get_public_ip "$finder"); then
        return 1
    fi

    # don't sanitize if -r was passed
    if [ -n "$public_raw" ]; then
        printf "%s\n" "$result"
        return
    fi

    # ensure whether the found IP is v4 or v6
    if printf "%s" "$result" | grep -i -q ':'; then
        # ipv6
        if [ "$ipv6_flag" -eq 1 ]; then
            printf "%s\n" "$result"
        else
            log error "Failed to get public IPv4 using $finder. Found $result"
            return 1
        fi
    else
        # ipv4
        if [ "$ipv6_flag" -eq 1 ]; then
            log error "Failed to get public IPv6 using $finder. Found $result"
            return 1
        else
            printf "%s\n" "$result"
        fi
    fi
}

show_public_ip() {
    is_found=0
    for finder in $finders; do
        log debug "Trying fetching public IP using $finder"
        if get_public_ip_santinized "$finder"; then
            is_found=1
            log debug "Successfully found public IP using $finder"
            break
        fi
    done
    if [ $is_found -eq 0 ]; then
        if [ "$special_formatting" -eq 1 ]; then
            printf "×\n"
            return 1
        else
            log error "No public IP was found"
            return 1
        fi
    fi
}

handle_public_cmd() {
    _only_do_list=""
    OPTIND=1
    while getopts hlre: opt; do
        case $opt in
            h)
                show_help
                exit
                ;;
            e)
                exclude_re="$OPTARG"
                ;;
            l)
                _only_do_list=1
                ;;
            r)
                public_raw=1
                ;;
            *)
                log error "Bad usage! Check help (-h)"
                exit 2
                ;;
        esac
    done
    shift "$((OPTIND - 1))"
    if [ -n "$1" ]; then
        finders="$1"
        finders=$(printf "%s" "$finders" | tr , '\n' | awk '{$1=$1; print}')
    fi

    if [ -n "$exclude_re" ]; then
        if ! finders=$(printf "%s" "$finders" | grep -v "$exclude_re"); then
            log error "Failed to filter public IP finders"
            return 1
        fi
    fi
    log debug "finders = $(printf "%s\n" "$finders" | tr '\n' ',')"

    # handle -l switch (if passed) and return
    if [ -n "$_only_do_list" ]; then
        printf "%s\n" "$finders"
        return
    fi

    if ! show_public_ip; then
        return 1
    fi
}

list_interfaces() {
    OPTIND=1
    while getopts h opt; do
        case $opt in
            h)
                show_help
                exit
                ;;
            *)
                log error "Bad usage! Check help (-h)"
                exit 2
                ;;
        esac
    done
    shift "$((OPTIND - 1))"

    if check_deps -q ip; then
        # handle busybox
        if ip -V 2>&1 | grep -i -q 'busybox'; then
            if [ "$ipv6_flag" -eq 1 ]; then
                ip -o -6 addr \
                    | awk -v sep="$l_sep" \
                        '/inet6/ { split($4, ip, "/"); print ip[1] sep $2 }'
            else
                ip -o -4 addr \
                    | awk -v sep="$l_sep" \
                        '/inet/ { split($4, ip, "/"); print ip[1] sep $2 }'
            fi
            return
        fi
        if [ "$ipv6_flag" -eq 1 ]; then
            ip -6 -brief address
        else
            ip -4 -brief address
        fi

    elif [ -e /sys/class/net ]; then
        ls /sys/class/net

    # handle windows/msys2 case
    elif uname -a | grep -q -i 'mingw'; then
        check_deps netsh || return 1
        if [ "$ipv6_flag" -eq 1 ]; then
            netsh interface ipv6 show addresses
        else
            netsh interface ip show addresses
        fi
    fi
}

# unit conversion
# in this function, Tx/Rx is limited to integers
format_val_sh() {
    diff_val="$1"
    fmt_val=""
    if [ "$diff_val" -lt 1024 ]; then
        # we are in Bytes range
        fmt_val="$diff_val"
        fmt_val=$(printf "%4d B" "$fmt_val")
    elif [ "$diff_val" -ge 1024 ] \
        && [ "$diff_val" -lt 1048576 ]; then
        # we are in KibiBytes range
        fmt_val=$((diff_val >> 10))
        fmt_val=$(printf "%4d K" "$fmt_val")
    else
        # we are in MebiBytes range
        fmt_val=$((diff_val >> 20))
        fmt_val=$(printf "%4d M" "$fmt_val")
    fi
    printf "%s" "$fmt_val"
}

# this function uses bc only in MiB range
format_val_bc() {
    diff_val="$1"
    fmt_val=""
    if [ "$diff_val" -lt 1024 ]; then
        # we are in Bytes range
        fmt_val="$diff_val"
        fmt_val=$(printf "%6d B" "$fmt_val")
    elif [ "$diff_val" -ge 1024 ] \
        && [ "$diff_val" -lt 1048576 ]; then
        # we are in KibiBytes range
        fmt_val=$((diff_val >> 10))
        fmt_val=$(printf "%6d K" "$fmt_val")
    else
        # we are in MebiBytes range
        fmt_val=$(printf "scale=1; %s / (1024 * 1024)\n" "$diff_val" | bc)
        fmt_val=$(printf "%6.1f M" "$fmt_val")
    fi
    printf "%s" "$fmt_val"
}

watch_bw_linux_direct() {
    dev="$1"
    read -r rx < "/sys/class/net/$dev/statistics/rx_bytes"
    read -r tx < "/sys/class/net/$dev/statistics/tx_bytes"

    # delay for 0.5 sec which result in sampling frequency to be 2 Hz
    while sleep 0.5; do
        # raw bytes
        read -r newrx < "/sys/class/net/$dev/statistics/rx_bytes"
        read -r newtx < "/sys/class/net/$dev/statistics/tx_bytes"

        # raw bytes
        # multplication by f = 1/delay = 2 Hz
        diff_rx=$((2 * (newrx - rx)))
        diff_tx=$((2 * (newtx - tx)))

        # formatted values
        fmt_diff_rx=$(format_val_bc "$diff_rx")
        fmt_diff_tx=$(format_val_bc "$diff_tx")
        # printing the final result
        printf "%s: ↓%s • ↑%s\t\r" "$dev" "$fmt_diff_rx" "$fmt_diff_tx"

        # updating the values
        rx=$newrx
        tx=$newtx
    done
}

watch_bw_win_netstat() {
    read -r rx tx << EOF
$(netstat -e | awk '/Bytes/{print $2, $3}')
EOF
    # delay for 1 sec which result in sampling frequency to be 1 Hz
    while sleep 1; do
        # raw bytes
        read -r newrx newtx << EOF
$(netstat -e | awk '/Bytes/{print $2, $3}')
EOF
        # raw bytes
        # multplication by f = 1/delay = 1 Hz
        diff_rx=$((newrx - rx))
        diff_tx=$((newtx - tx))

        # formatted values
        fmt_diff_rx=$(format_val_bc "$diff_rx")
        fmt_diff_tx=$(format_val_bc "$diff_tx")
        # printing the final result
        printf "↓%s • ↑%s\t\r" "$fmt_diff_rx" "$fmt_diff_tx"

        # updating the values
        rx=$newrx
        tx=$newtx
    done
}

watch_bandwidth() {
    OPTIND=1
    while getopts h opt; do
        case $opt in
            h)
                show_help
                exit
                ;;
            *)
                log error "Bad usage! Check help (-h)"
                exit 2
                ;;
        esac
    done
    shift "$((OPTIND - 1))"

    dev=$1
    if uname -a | grep -q -i 'linux'; then
        if [ -z "$dev" ]; then
            log error "Bad usage! No interface was passed. Run 'netq list'"
            return 2
        fi
        if ! grep -q "$dev:" /proc/net/dev; then
            log error "No such interface: '$dev'. Run 'netq list'"
            return 1
        fi
        watch_bw_linux_direct "$dev"
    elif uname -a | grep -q -i 'mingw'; then
        # handle windows/msys2
        check_deps netstat || return 1
        watch_bw_win_netstat
    else
        log error "Unsupported platform"
        return 1
    fi
}

handle_check_cmd() {
    ping_mode=0

    OPTIND=1
    while getopts hp opt; do
        case $opt in
            h)
                show_help
                exit
                ;;
            p)
                ping_mode=1
                ;;
            *)
                log error "Bad usage! Check help (-h)"
                exit 2
                ;;
        esac
    done
    shift "$((OPTIND - 1))"
    if [ -n "$1" ]; then
        check_url="$1"
    fi

    if [ "$ping_mode" -eq 1 ]; then
        while ! str=$(ping -c 1 -W 3 "$ping_ip"); do
            printf "%s: %s\n" "$(date "+%b %d %H:%M:%S")" "$str"
            sleep 1s
        done
        printf "%s: online\n" "$(date "+%b %d %H:%M:%S")"
        return
    fi

    if fetch "$check_url" > /dev/null; then
        log info "Success in downloading $check_url"
    else
        log error "Failed to get $check_url"
        return 1
    fi
}

handle_cmd() {
    while getopts Vvq64hf opt; do
        case $opt in
            h)
                show_help
                exit
                ;;
            V)
                printf "%s\n" "$version"
                exit
                ;;
            v)
                log_debug_flag=1
                log_quiet_flag=""
                ;;
            q)
                log_quiet_flag=1
                log_debug_flag=""
                ;;
            f)
                special_formatting=1
                ;;
            4)
                # default, declared for consistency
                ipv6_flag=0
                ;;
            6)
                ipv6_flag=1
                ;;
            *)
                log error "Bad usage! Check help (-h)"
                return 2
                ;;
        esac
    done
    shift "$((OPTIND - 1))"

    case $1 in
        "local" | "l" | "")
            show_local_ip || return 1
            ;;
        "public" | "p")
            shift
            handle_public_cmd "$@" || return 1
            ;;
        "bandwidth" | "bw" | "b")
            shift
            watch_bandwidth "$@" || return 1
            ;;
        "list" | "ls")
            shift
            list_interfaces || return 1
            ;;
        "check" | "c")
            shift
            handle_check_cmd "$@" || return 1
            ;;
        "help")
            show_help
            exit 0
            ;;
        *)
            log error "Bad usage! Unknown command: '$1'. Check help (-h)"
            return 2
            ;;
    esac
}

handle_cmd "$@"
